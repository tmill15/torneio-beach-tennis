# Role & Objetivo
Atue como um Engenheiro de Software Sênior e Product Manager. Estamos construindo o "Torneio de Beach Tennis", um app para gestão de torneios.

# 1. Referência Técnica (OBRIGATÓRIO)
- **Base de Código:** Espelhar padrões (stack, arquitetura, linting, backup) de: `https://github.com/tmill15/sorteador-duplas`.
- **Estilo:** Simplicidade, UX limpa, Mobile-first, PWA.
- **Backup:** Inclua um esquema de backup, para exportar/importar o estado atual de um torneio: participantes, jogos, ranking e etc.

# 2. Regras de Negócio "Hard" (Imutáveis)

## A. Estrutura Geral
- **Categorias:** O sistema deve separar dados por categorias (Ex: "Iniciante" e "Normal"). Será possível criar as categorias.
- **Nome:** O sistema aceita configurar o nome do torneio.

## B. Inscrição & Formação (Regra dos Blocos)
- **Tamanho do Grupo:** Alvo = 4 duplas.
- **Lista de Espera:** Inscrições ilimitadas. Excedentes ficam em espera até formarem um novo grupo completo de 4.

## C. Seeds (Cabeças de Chave)
- **Distribuição:** Antes do sorteio, distribuir seeds uniformemente entre os grupos.

## D. Geração de Jogos (Sorteio dos Confrontos)
- **Algoritmo:** Ao fechar um grupo, o sistema deve gerar automaticamente a lista de jogos no formato "Round Robin" (Todos contra todos).
- **Exemplo (Grupo de 4):**
  - Rodada 1: A x B, C x D
  - Rodada 2: A x C, B x D
  - Rodada 3: A x D, B x C
- **Quantidade:** Cada dupla deve jogar exatamente o mesmo número de vezes dentro da fase.

## E. Pontuação & Ranking
- **Critérios:** 1. Vitórias -> 2. Saldo Games -> 3. Empate Técnico (Manual).
- **Input de Placar:**
  - A interface deve permitir inserir o placar (Ex: 6 x 2).
  - O ranking do grupo deve atualizar automaticamente assim que um placar for salvo.

## F. UI/UX: Dashboard & Fases (O Funil)
- **Fluxo:** Fase 1 (Grupos) -> Fases Seguintes (Novos Grupos misturados) -> Final (Grupo Único).
- **Visualização:** Cards de Grupos contendo a Tabela de Classificação e a Lista de Jogos logo abaixo (ou em um modal).

## G. Protocolo de Versionamento & Deploy (CI/CD)
- **Não altere a versão manualmente.** O versionamento agora é gerido automaticamente pelo GitHub Actions.
- **Commit Messages (OBRIGATÓRIO):** Ao sugerir mensagens de commit, siga estritamente o padrão **Conventional Commits**:
  - `feat: descrição` para novas funcionalidades (Gera versão Minor).
  - `fix: descrição` para correção de bugs (Gera versão Patch).
  - `chore: descrição` para tarefas técnicas, refatoração ou docs (Não altera versão).
  - `BREAKING CHANGE: descrição` se quebrar compatibilidade (Gera versão Major).
  - Nunca sugira commit direto na `main`. Sempre crie branches `feat/nome` ou `fix/nome`.
  - A versão do app no Footer deve ler a variável `__APP_VERSION__` definida no Vite.
  
## H. Mensagens de Commit (Regra de Ouro):
- **feat:** para novas funcionalidades (Ex: `feat: adiciona calculo de saldo de games`).
- **fix:** para correção de bugs (Ex: `fix: corrige ordenação da tabela iniciante`).
- **chore:** para mudanças em builds, dependências, arquivos de config ou README (Ex: `chore: atualiza readme`).
- **refactor:** para melhorias no código que não alteram funcionalidade.
- **Não use letras maiúsculas no início da mensagem.**
- **Seja direto e descreva a mudança técnica.**

# 3. Sincronização & Performance (Vercel KV + SWR)
- **Modo Espectador:** Use a biblioteca `swr`. Configure `refreshInterval: 60000` (1 min) e `revalidateOnFocus: true`.
- **Modo Admin (Escrita Otimizada):** - Implementar "Dirty Checking": Só enviar dados ao KV se houver mudança real.
  - Implementar "Debounce": Aguardar 2 segundos após a última alteração antes de disparar o POST para `/api/save`.
  - Exibir status de sincronização na UI (Salvando/Salvo).
- **Segurança:** Apenas usuários com uma `adminToken` no localStorage podem realizar POST para a API de save.

# 4. Instruções para o Cursor
- Sempre verifique `PROJECT_STATUS.md`.
- Mantenha atualizado `PROJECT_STATUS.md`.
- Na UI do Grupo, mostre claramente: "Jogos Pendentes" e "Jogos Concluídos".
- Use Functional Components e Hooks.